<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lyra Chatbot</title>
    <!-- Carica Tailwind CSS per uno styling rapido e responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- sql.js rimosso, useremo IndexedDB -->

    <style>
        /* Stili globali per il corpo della pagina */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Sfondo leggermente grigio */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Altezza minima del 100% della viewport */
            margin: 0;
            padding: 20px;
            box-sizing: border-box; /* Include padding e border nel calcolo della larghezza/altezza */
        }
        /* Contenitore principale della chat */
        .chat-container {
            background-color: #ffffff;
            border-radius: 1rem; /* Angoli arrotondati */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Ombra leggera */
            width: 100%;
            max-width: 600px; /* Larghezza massima per desktop */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Nasconde il contenuto che eccede i bordi */
            height: 80vh; /* Altezza fissa per la finestra di chat, si adatta alla viewport */
        }
        /* Intestazione della chat */
        .chat-header {
            background-color: #4f46e5; /* Viola profondo */
            color: white;
            padding: 1.5rem;
            text-align: center;
            font-size: 1.5rem;
            font-weight: 700;
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
            position: relative; /* Per posizionare il dot di stato */
        }
        /* Area dei messaggi della chat */
        .chat-messages {
            flex-grow: 1; /* Permette all'area dei messaggi di occupare lo spazio disponibile */
            padding: 1.5rem;
            overflow-y: auto; /* Abilita lo scroll verticale per i messaggi */
            display: flex;
            flex-direction: column;
            gap: 1rem; /* Spazio tra i messaggi */
        }
        /* Stile comune per le bolle dei messaggi */
        .message-bubble {
            max-width: 80%; /* Larghezza massima della bolla */
            padding: 0.75rem 1rem;
            border-radius: 0.75rem; /* Angoli arrotondati per le bolle */
            word-wrap: break-word; /* Va a capo se la parola è troppo lunga */
        }
        /* Stile per i messaggi dell'utente */
        .user-message {
            background-color: #e0e7ff; /* Azzurro chiaro per i messaggi utente */
            align-self: flex-end; /* Allinea a destra */
            color: #333;
        }
        /* Stile per i messaggi di Lyra */
        .lyra-message {
            background-color: #f0f4f8; /* Grigio chiaro per i messaggi Lyra */
            align-self: flex-start; /* Allinea a sinistra */
            color: #333;
        }
        /* Area di input della chat */
        .chat-input-area {
            display: flex;
            padding: 1.5rem;
            border-top: 1px solid #e2e8f0; /* Bordo superiore sottile */
            background-color: #ffffff;
        }
        /* Campo di input del messaggio */
        .chat-input {
            flex-grow: 1; /* Permette all'input di occupare lo spazio disponibile */
            padding: 0.75rem 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.75rem;
            outline: none; /* Rimuove il bordo di focus predefinito */
            font-size: 1rem;
        }
        /* Stile del campo di input al focus */
        .chat-input:focus {
            border-color: #6366f1; /* Bordo viola al focus */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); /* Ombra al focus */
        }
        /* Pulsante di invio */
        .send-button {
            background-color: #6366f1; /* Viola */
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.75rem;
            margin-left: 1rem;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease; /* Transizioni fluide */
        }
        /* Stile del pulsante di invio al hover */
        .send-button:hover {
            background-color: #4f46e5; /* Viola più scuro al hover */
            transform: translateY(-1px); /* Piccolo effetto di sollevamento */
        }
        /* Stile del pulsante di invio all'attivazione (click) */
        .send-button:active {
            transform: translateY(0); /* Ritorna alla posizione originale */
        }
        /* Indicatore di caricamento */
        .loading-indicator {
            text-align: center;
            padding: 1rem;
            color: #6b7280;
            font-style: italic;
        }

        /* Nuovi stili per la formattazione dei messaggi di Lyra */
        .lyra-message strong {
            font-weight: 700; /* Rende il testo in grassetto più evidente */
            color: #312e81; /* Un colore più scuro per il grassetto */
        }

        .lyra-message code {
            background-color: #e2e8f0; /* Sfondo leggero per il codice inline */
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 0.3rem;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            color: #c026d3; /* Colore viola per il testo del codice inline */
        }

        .lyra-message pre {
            background-color: #1f2937; /* Sfondo scuro per i blocchi di codice */
            color: #f8fafc; /* Testo chiaro per i blocchi di codice */
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto; /* Abilita lo scroll orizzontale per i blocchi di codice lunghi */
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            Lyra Chatbot
            <div id="user-id-display" class="text-xs mt-1">ID Utente: Caricamento...</div>
        </div>
        <div class="chat-messages" id="chat-messages">
            <!-- I messaggi della chat verranno inseriti qui dal JavaScript -->
            <div class="message-bubble lyra-message">Ciao! Sono Lyra, il tuo assistente. Come posso aiutarti oggi?</div>
        </div>
        <div class="chat-input-area">
            <input type="text" id="user-input" class="chat-input" placeholder="Scrivi qui il tuo messaggio...">
            <button id="send-button" class="send-button">Invia</button>
        </div>
    </div>

    <script>
        let db; // Global variable for the IndexedDB database
        let currentUserId = null; // Variable to store the user ID

        // Utility function to show a custom alert message
        function showCustomAlert(message) {
            const alertBox = document.createElement('div');
            alertBox.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50';
            alertBox.innerHTML = `
                <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
                    <p class="text-lg font-semibold text-red-600 mb-4">${message}</p>
                    <button id="alert-ok-button" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">
                        OK
                    </button>
                </div>
            `;
            document.body.appendChild(alertBox);

            document.getElementById('alert-ok-button').onclick = () => {
                alertBox.remove();
            };
        }

        // Initialize IndexedDB and generate/retrieve user ID
        async function initIndexedDbAndUser() {
            return new Promise((resolve, reject) => {
                // Try to get the user ID from localStorage first for persistence across sessions
                currentUserId = localStorage.getItem('lyraChatUserId');
                if (!currentUserId) {
                    currentUserId = crypto.randomUUID();
                    localStorage.setItem('lyraChatUserId', currentUserId);
                }
                document.getElementById('user-id-display').textContent = `ID Utente: ${currentUserId}`;
                console.log("User ID:", currentUserId);

                const request = indexedDB.open('LyraChatDB', 1);

                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.errorCode);
                    showCustomAlert(`Errore IndexedDB: ${event.target.errorCode}. Impossibile aprire il database.`);
                    reject(event.target.errorCode);
                };

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    // Create an object store for messages if it doesn't exist
                    // KeyPath 'id' is automatically incremented
                    const objectStore = db.createObjectStore('messages', { keyPath: 'id', autoIncrement: true });
                    // Create an index on 'userId' to efficiently query messages for a specific user
                    objectStore.createIndex('userId', 'userId', { unique: false });
                    // Create an index on 'timestamp' for ordering messages
                    objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                    console.log("IndexedDB object store 'messages' created/upgraded.");
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("IndexedDB 'LyraChatDB' opened successfully.");
                    loadChatMessages(); // Load messages after DB is ready
                    resolve();
                };
            });
        }

        // Get references to HTML elements
        const chatMessages = document.getElementById('chat-messages');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');

        /**
         * Shows or hides the loading indicator.
         * @param {boolean} show - True to show, False to hide.
         */
        function showLoading(show) {
            let loadingDiv = document.getElementById('loading-indicator');
            if (show) {
                if (!loadingDiv) {
                    loadingDiv = document.createElement('div');
                    loadingDiv.id = 'loading-indicator';
                    loadingDiv.classList.add('loading-indicator');
                    loadingDiv.textContent = 'Lyra sta digitando...';
                    chatMessages.appendChild(loadingDiv);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            } else {
                if (loadingDiv) {
                    loadingDiv.remove();
                }
            }
        }

        /**
         * Processes message text to apply Markdown formatting (bold, code).
         * @param {string} text - The message text to process.
         * @returns {string} The message text with HTML formatting applied.
         */
        function formatMessageContent(text) {
            // Replaces multiline code blocks (```code```) with <pre><code>
            text = text.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');

            // Replaces bold text (**text** or *text*) with <strong>
            // Ensure there are no spaces between asterisks and text
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/\*(.*?)\*/g, '<strong>$1</strong>'); // Also supports single asterisk for bold

            // Replaces inline code (`code`) with <code>
            text = text.replace(/`([^`]+)`/g, '<code>$1</code>');

            return text;
        }

        /**
         * Simulates a typing effect for a message.
         * The text is typed character by character, and Markdown formatting is applied only at the end.
         * @param {HTMLElement} element - The HTML element (a span inside the message bubble) to type the text into.
         * @param {string} fullText - The complete text to type (Lyra's raw response).
         * @returns {Promise<void>} A Promise that resolves when typing is complete.
         */
        function typeMessage(element, fullText) {
            return new Promise(resolve => {
                let i = 0;
                const typingSpeed = 20; // Milliseconds per character (adjust for desired speed)

                function typeChar() {
                    if (i < fullText.length) {
                        // Adds one character at a time to the textContent of the span
                        element.textContent += fullText.charAt(i);
                        // Automatically scroll down while typing
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                        i++;
                        setTimeout(typeChar, typingSpeed);
                    } else {
                        // Once all text is typed, apply Markdown formatting to the innerHTML of the parent element
                        // Note: Here we are overwriting the innerHTML of the element that contained the typing span,
                        // to apply the HTML formatting.
                        element.parentElement.innerHTML = formatMessageContent(fullText);
                        chatMessages.scrollTop = chatMessages.scrollHeight; // Ensure scrolling to the end after formatting
                        resolve();
                    }
                }
                typeChar();
            });
        }

        /**
         * Adds a message to the chat window and saves it to IndexedDB.
         * @param {string} sender - The message sender ('user' or 'lyra').
         * @param {string} text - The message content.
         * @param {boolean} [animate=true] - If true, animates typing for Lyra's messages.
         * @param {boolean} [saveToDb=true] - If true, saves the message to IndexedDB. Set to false when loading from DB.
         * @returns {Promise<void>} A Promise that resolves when the message has been added (and typed, if Lyra).
         */
        async function addMessage(sender, text, animate = true, saveToDb = true) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message-bubble');

            if (sender === 'user') {
                messageDiv.classList.add('user-message');
                messageDiv.textContent = text; // User messages are not formatted
                chatMessages.appendChild(messageDiv);
            } else {
                messageDiv.classList.add('lyra-message');
                const typingContentSpan = document.createElement('span');
                messageDiv.appendChild(typingContentSpan);
                chatMessages.appendChild(messageDiv);

                if (animate) {
                    await typeMessage(typingContentSpan, text);
                } else {
                    messageDiv.innerHTML = formatMessageContent(text);
                }
            }
            chatMessages.scrollTop = chatMessages.scrollHeight;

            if (saveToDb && db) {
                const transaction = db.transaction(['messages'], 'readwrite');
                const objectStore = transaction.objectStore('messages');
                const messageData = {
                    sender: sender,
                    text: text,
                    userId: currentUserId,
                    timestamp: Date.now()
                };
                const request = objectStore.add(messageData);

                request.onsuccess = () => {
                    console.log("Message saved to IndexedDB:", messageData);
                };
                request.onerror = (event) => {
                    console.error("Error saving message to IndexedDB:", event.target.error);
                };
            }
            return Promise.resolve();
        }

        /**
         * Loads chat messages from IndexedDB.
         */
        async function loadChatMessages() {
            if (!db) {
                console.log("IndexedDB not yet ready, cannot load messages.");
                return;
            }

            try {
                const transaction = db.transaction(['messages'], 'readonly');
                const objectStore = transaction.objectStore('messages');
                const userIdIndex = objectStore.index('userId');
                const timestampIndex = objectStore.index('timestamp');

                const messages = [];
                // Use a cursor to retrieve messages for the current user, ordered by timestamp
                const request = userIdIndex.openCursor(IDBKeyRange.only(currentUserId), 'next');

                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        messages.push(cursor.value);
                        cursor.continue();
                    } else {
                        // Sort by timestamp after fetching all messages for the user
                        messages.sort((a, b) => a.timestamp - b.timestamp);

                        // Clear existing messages to avoid duplicates, keeping Lyra's initial message
                        const initialMessageElement = chatMessages.querySelector('.lyra-message');
                        chatMessages.innerHTML = ''; // Clear everything
                        if (initialMessageElement && initialMessageElement.textContent === 'Ciao! Sono Lyra, il tuo assistente. Come posso aiutarti oggi?') {
                            chatMessages.appendChild(initialMessageElement); // Restore the initial message
                        } else {
                            addMessage('lyra', 'Ciao! Sono Lyra, il tuo assistente. Come posso aiutarti oggi?', false, false); // Add if not present, don't save again
                        }

                        messages.forEach((msg) => {
                            // Add only messages that are not the initial welcome message
                            if (!(msg.sender === 'lyra' && msg.text === 'Ciao! Sono Lyra, il tuo assistente. Come posso aiutarti oggi?')) {
                                addMessage(msg.sender, msg.text, false, false); // Do not animate or save loaded messages again
                            }
                        });
                        console.log("Chat messages loaded from IndexedDB.");
                    }
                };

                request.onerror = (event) => {
                    console.error("Error loading messages from IndexedDB:", event.target.error);
                    showCustomAlert(`Errore nel caricamento della cronologia chat: ${event.target.error.message}. Controlla la console per dettagli.`);
                };

            } catch (error) {
                console.error("Error accessing IndexedDB:", error);
                showCustomAlert(`Errore nell'accesso a IndexedDB: ${error.message}. Controlla la console per dettagli.`);
            }
        }

        /**
         * Sends the user's message to the Python backend and handles the response.
         */
        async function sendMessage() {
            const message = userInput.value.trim();
            if (message === '') return; // Do not send empty messages
            if (!db) {
                showCustomAlert("Database non ancora pronto. Impossibile inviare messaggi. Attendi o ricarica la pagina.");
                return;
            }

            // Clear the input field immediately for better UX
            userInput.value = '';

            // Add the user's message to the chat and save it to IndexedDB
            await addMessage('user', message, true, true);

            showLoading(true);
            sendButton.disabled = true; // Disable the button during sending to prevent double clicks

            try {
                // Make a POST request to your Flask server
                // The URL must match the address where your Flask server is running
                const response = await fetch('http://127.0.0.1:5000/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ message: message }) // Send the message as JSON
                });

                // Check if the HTTP response is ok (status 200-299)
                if (!response.ok) {
                    const errorData = await response.json(); // Attempt to read error details from JSON
                    throw new Error(errorData.error || `Errore HTTP: ${response.status}`);
                }

                const data = await response.json(); // Parse the JSON response
                // Add Lyra's response with the typing effect and save it to IndexedDB
                await addMessage('lyra', data.reply, true, true);

            } catch (error) {
                console.error('Error sending message or saving to IndexedDB:', error);
                // In case of error, add an error message without typing effect
                addMessage('lyra', `Mi dispiace, si è verificato un errore: ${error.message}. Riprova più tardi.`, false, false); // Don't try to save an error message to DB if DB is the issue
            } finally {
                showLoading(false);
                sendButton.disabled = false; // Re-enable the button
                userInput.focus(); // Put focus back on the input field for easy typing
            }
        }

        // Add event listener for the "Send" button click
        sendButton.addEventListener('click', sendMessage);

        // Add event listener for the "Enter" key in the input field
        userInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });

        // Initialize the database and user on page load
        window.onload = initIndexedDbAndUser;
    </script>
</body>
</html>
